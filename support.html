<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8">
		<script type='text/x-mathjax-config'>
	  MathJax.Hub.Config({
	    tex2jax: {
	      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
	      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
	      processEscapes: true
	    },
	    "HTML-CSS": { availableFonts: ["TeX"] }
	  });
	</script>
	<script async='async' src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML' type='text/javascript'>
	</script>
	<title>Support functions with non uniform scaling</title><link rel="stylesheet" type="text/css" href="style.css"></head><body><div class="column"><div class="header"><a href="index.html">Home</a></div><hr><div class="content"><h2>Support functions with non uniform scaling</h2>
<p>
Given a support function $S_{\text{obj}}(d)$ and a non uniform scale vector you can create a new support function</p>

<p>
$S_{\text{scaled}}(d) = S(d * scale) * scale$</p>
<p>
where * denotes a component wise vector multiplication.</p>

<p>
Consider that $S_{\text{obj}}(d) = \{\ x\ |\ x \cdot d \ge y \cdot d\ \forall x,y \in \text{obj}\}$</p>

<p>
Then if we apply a transform to all points in obj the statement becomes:</p>

<p>
$S_{\text{scaled}}(d) = \{\ Ax\ |\ Ax \cdot d \ge Ay \cdot d \ \forall x,y \in obj\}$</p>
<p>
But note:</p>
<p>
$Ax \cdot d = d^T Ax = (d^T A) x = (A^Td)^T x = x \cdot A^T d$</p>
<p>
In the case of non uniform scale A is a diagonal matrix so $A^Td$ is simply a component wise vector multiplication.</p>
<p>
Remember that $S_{\text{obj}}(A^T d) = \{\ x\&nbsp; |\ x \cdot A^T d \ge y \cdot A^T d\}$ </p>
<p>
But&nbsp; $S_{\text{scaled}}$ must return $Ax$, so we need to multiply the result by $A^T$, which in the case of non uniform scale requires&nbsp;a second component wise vector multiplication.</p>
<p>
The general matrix works as well:</p>
<p>
$S_A(d) = A\ S(A^T d)$
</p><div class="footer">May 13 2019<br /><a href="index.html">Home</a></div></div></div></body></html>